# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vJFBmXs2oNMzxGFu85HkHVSBv2nnqnOH

we have declare a variable nammed by x and will show it with print
"""

x = 10
print(x)

"""as you see here we declare two variables with same name but with diff types (int ,String)"""

x = 10
x = 'hello'

"""we make class instance with diff param"""

x = 10
x = 'hello'

"""## Python dataclasses offer basic type hints for better clarity.
## They help developers understand expected types.
## However, they don't prevent invalid data at runtime.
## This is helpful, but not fully safe.
## Pydantic is a library for strict type validation at runtime.
## It prevents wrong data from entering your system.
## The model extends BaseModel and enforces correct types.
## It’s ideal for API input validation and cleaner code.
"""

@dataclass
class Person:
    name: str
    age: str

# Using Pydantic
class Person(BaseModel):
    name: str
    email: EmailStr
    account_id: int

"""installing bib pydantic"""

pip install pydantic

"""## Pydantic is a library for strict type validation at runtime.
## It prevents wrong data from entering your system.
## The model extends BaseModel and enforces correct types.
## It’s ideal for API input validation and cleaner code.
"""

from pydantic import BaseModel

class User(BaseModel):
    name: str
    email: str
    account_id: int

"""## Creating a Pydantic model instance with correct data.
## If the types match, the object is created successfully.
## You get type-safe attributes with autocompletion.
## This ensures safer code and better debugging.

"""

user = User(
    name = "Salah",
    email = "salah@gmail.com",
    account_id = 12345
)

"""## You can also create a Pydantic model from a dictionary.
## The double asterisks (**) unpack the dictionary keys.
## Validation still runs even if the source is a dict.
## This is useful when loading data from JSON/APIs.
"""

user_data = {
    'name': 'Salah',
    'email': 'salah@gmail.com',
    'account_id': 12345
}

user = User(**user_data)

"""showing username user email and account_id"""

print(user.name)    # Salah
print(user.email)    # salah@gmail.com
print(user.account_id)    # 12345

"""## If you pass invalid data types, Pydantic raises errors.
## This avoids issues later in the code.
## It forces the developer to fix problems early.
## That makes debugging and testing much easier.
"""

from pydantic import BaseModel, EmailStr

class User(BaseModel):
    name: str
    email: EmailStr
    account_id: int

# Corrected instantiation
user = User(name='Ali', email='ali@gmail.com', account_id=123)
print(user)

"""## You can validate emails using Pydantic’s EmailStr type.
## It checks if the input is a valid email format.
## If it’s not valid, Pydantic throws a validation error.
## This is great for ensuring user input is correct.
"""

from pydantic import BaseModel, EmailStr

class User(BaseModel):
    name: str
    email: EmailStr     # pip install pydantic[email]
    account_id: int

# It will fail and show a validation error with email = 'ali'
user = User(name = 'Ali', email = 'ali', account_id = 1234)
print(user)

"""## You can add custom validation logic to fields.
## Here, we make sure account_id is a positive number.
## If it’s zero or negative, a validation error is raised.
## This helps enforce strict rules in your model.

"""

from pydantic import field_validator

class User(BaseModel):
    name: str
    email: EmailStr
    account_id: int

    @field_validator("account_id")
    def validate_account_id(cls, value):
        if value <= 0:
            raise ValueError("account_id must be positive")
        return value

try:
    user = User(name='Ali', email='ali@gmail.com', account_id=-12)
except ValidationError as e:
    print(e)

"""## Pydantic allows easy conversion of models to JSON strings.
## Use model_dump_json() to get a JSON representation.
## You can also get a Python dict with model_dump().
## This is helpful for APIs and saving to files.
"""

# you will get a validation error with account_id = -12
user = User(name = 'Ali', email = 'ali', account_id = -12)
print(user)

show the user_json_str

user_json_str = user.model_dump_json()
# this will return a JSON strinf representation of the model's data
print(user_json_str)

"""## You can load a Pydantic model from a raw JSON string.
## Use parse_raw() for that purpose.
## This is useful when loading API responses or files.
## It gives back a fully validated model.
"""

json_str = '{"name": "Ali", "email": "ali@gmail.com", "account_id": 1234}'

user = User.parse_raw(json_str)
print(user)

user_json_obj = user.model_dump()

"""## You can load a Pydantic model from a raw JSON string.
## Use parse_raw() for that purpose.
## This is useful when loading API responses or files.
## It gives back a fully validated model.
"""

json_str = '{"name": "Ali", "email": "ali@gmail.com", "account_id": 1234}'

user = User.parse_raw(json_str)
print(user)

# Python 3.6+
x: int = 0
y: str = "hello"

"""## Python dataclasses offer basic structure without validation.
## You can use type hints but they’re not enforced.
## This is fine for simple programs but not strict apps.
## Unlike Pydantic, invalid values won’t raise errors.
"""

from dataclasses import dataclass

@dataclass
class User:
    name: str
    email: str
    account_id: int

u = User(name="Ali", email=1234, account_id="not_an_int")
print(u)